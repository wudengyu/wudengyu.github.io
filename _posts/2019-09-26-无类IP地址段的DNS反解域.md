---
layout: post
title:  "无类IP地址段的DNS反解域"
date:    2019-09-26 01:35:49 +0800
categories: jekyll update
---
首先，通过dig +trace -x 跟踪反解过程可以得知，DNS反解的查询过程跟正解其实是一样的，依然是从根向下查询。也就是说，存在in-addr.arpa.这个域，公网可用的所有A、B、C三类IP地址从1.x.x.x到223.x.x.x都要在这里有记录才可能被反解出来。当然，这里只管IP地址的第一个字节由那一个域来解析。同样地，192.in-addr.arpa.这个域的NS就负责192.x.x.x这一网段的反解。如此类推，跟正解没什么差别。只不过正解域名通常是字母，反解IP是数字而已。

但是，这种把正解的方法应用到反解上有一个问题，就是IP地址不能像域名一样向下扩展，只有那么固定的4级，也就是说，按这个规则配置反解DNS域的话，这个域至少应该是一个C类IP段的拥有者，但是IP地址已经不可能这么大段在段的分配了，而是采用变长掩码的方式，如：192.0.2.0/25、192.0.2.128/26、192.0.2.192/26这样分配。当然，这三段IP的反解交由192.0.2.0/24这一个大段的拥有者来反解应该是可行的……，但是……192.0.2.0/24这一大段已经完全分配出去了啊，难道要由192.0.这一个域来解析其下所有具体的IP吗？可是可以，这么多IP，只要其中一个域名变化，都得去处理，很麻烦。那么由192.0.2.0/25这个组织来解析呢？其他两段的又不干了，大家级别差不多，凭什么受你限制。RFC2317描述了这个问题，也解决了这个问题。方法其实很简单。

在192.0.这个domain的192.0.2这个zone里面，按照IP划分方法，定义0/25、128/26、192/26这几个NS，然后这几个IP段内的IP就用CNAME指向一个带掩码长度的IP名称上。如：1 CNAME 1.0/25.2.0.192.in-addr.arpa.这样。然后在192.0.2.0/25这一个段的NS上，定义一个0/25.2.0.192.in-addr.arpa.这样的zone，然后里面就是具体的PTR了。反正是把IP地址当域名来对待，反解区域名称多个反斜杠也没什么大不了的。这样子做，虽然还是得由上一级也就是192.0这一级来设置别名，但是可以根据IP地址的分配方案一次性配置好数据，不需要过问具体的IP与域名的对应，具体的反解对应关系还是由各自IP地址的所有者来做，这样就和谐了。